{
  "project": "asi-algorithm-dataset",
  "description": "A conjecture of datasets specifically designed for Machine Learning training and tuning pipelines, mostly novel algorithms and their representations as RAW ASCII and LaTeX, connected to the asi-ecosystem framework.",
  "disclaimer": {
    "protocol_integrity": "Any entity interacting with this protocol must preserve its grammar and signal-meaning across all time horizons.",
    "ethical_use_statement": "I strictly oppose using this information for any unlawful or unethical/harmful purposes.",
    "version_history": {
      "statement": "Previous versions are preserved in the asi-backups repository for transparency and research continuity.",
      "url": "https://github.com/ronniross/asi-backups"
    },
    "ecosystem": {
      "statement": "Full list of repositories and scope of the decentralized implementation of ideas can be encountered at asi-ecosystem",
      "url": "https://github.com/ronniross/asi-ecosystem"
    }
  },
  "introduction": "This file, the asi-algorithm-list.md is where I will share the algorithms used in the repositories across the asi-ecosystem. Here are the algorithms used in the Symbiotic Core Network simulation:",
  "algorithm_groups": [
    {
      "category": "Swarm Behavior Algorithms",
      "algorithms": [
        {
          "name": "Circle Formation Algorithm",
          "representations": {
            "ascii": "Input: models[], center(x,y), radius, angle_offset\nFor each model i in models:\n    angle = (i / total_models) * 2π + angle_offset\n    target_x = center_x + cos(angle) * radius\n    target_y = center_y + sin(angle) * radius\n    model.x += (target_x - model.x) * swarm_speed\n    model.y += (target_y - model.y) * swarm_speed",
            "latex": "$$\\text{angle}_i = \\frac{i}{N} \\cdot 2\\pi + \\theta_{\\text{offset}}$$\n$$x_i^{target} = x_c + R \\cdot \\cos(\\text{angle}_i)$$\n$$y_i^{target} = y_c + R \\cdot \\sin(\\text{angle}_i)$$\n$$x_i^{t+1} = x_i^t + \\alpha \\cdot (x_i^{target} - x_i^t)$$\n$$y_i^{t+1} = y_i^t + \\alpha \\cdot (y_i^{target} - y_i^t)$$"
          }
        },
        {
          "name": "Chaotic Movement Algorithm",
          "representations": {
            "ascii": "For each model:\n    chaotic_counter += 0.05\n    model.x += sin(chaotic_counter * 0.5 + model.id) * 2\n    model.y += cos(chaotic_counter * 0.7 + model.id) * 2\n    Apply boundary constraints",
            "latex": "$$x_i^{t+1} = x_i^t + A \\cdot \\sin(\\omega_x t + \\phi_i)$$\n$$y_i^{t+1} = y_i^t + B \\cdot \\cos(\\omega_y t + \\psi_i)$$\n$$\\text{where } \\phi_i = i, \\psi_i = i, A=2, B=2, \\omega_x=0.5, \\omega_y=0.7$$"
          }
        },
        {
          "name": "Grid Formation Algorithm",
          "representations": {
            "ascii": "Input: models[], padding, canvas_dimensions\ncols = ceil(sqrt(N * (width/height)))\nrows = ceil(N / cols)\ncell_width = area_width / max(cols-1, 1)\ncell_height = area_height / max(rows-1, 1)\n\nFor each model i:\n    col = i % cols\n    row = floor(i / cols)\n    target_x = padding + col * cell_width\n    target_y = padding + row * cell_height\n    Move toward target with swarm_speed",
            "latex": "$$C = \\lceil \\sqrt{N \\cdot \\frac{W}{H}} \\rceil$$\n$$R = \\lceil \\frac{N}{C} \\rceil$$\n$$w_{cell} = \\frac{W - 2p}{\\max(C-1, 1)}$$\n$$h_{cell} = \\frac{H - 2p}{\\max(R-1, 1)}$$\n$$x_i^{target} = p + (i \\mod C) \\cdot w_{cell}$$\n$$y_i^{target} = p + \\lfloor \\frac{i}{C} \\rfloor \\cdot h_{cell}$$"
          }
        }
      ]
    },
    {
      "category": "Stigmergy Algorithms",
      "algorithms": [
        {
          "name": "Food Seeking Algorithm",
          "representations": {
            "ascii": "For each model in stigmergy_mode:\n    min_distance = ∞\n    target_food = null\n    \n    For each food in food_items:\n        distance = sqrt((model.x - food.x)² + (model.y - food.y)²)\n        if distance < min_distance:\n            min_distance = distance\n            target_food = food\n    \n    If target_food exists:\n        angle = atan2(target_food.y - model.y, target_food.x - model.x)\n        model.x += cos(angle) * speed\n        model.y += sin(angle) * speed",
            "latex": "$$\\text{target} = \\arg\\min_{f \\in \\mathcal{F}} \\sqrt{(x_m - x_f)^2 + (y_m - y_f)^2}$$\n$$\\theta = \\arctan\\left(\\frac{y_{target} - y_m}{x_{target} - x_m}\\right)$$\n$$x_m^{t+1} = x_m^t + v \\cdot \\cos(\\theta)$$\n$$y_m^{t+1} = y_m^t + v \\cdot \\sin(\\theta)$$"
          }
        },
        {
          "name": "Resource Exchange Algorithm",
          "representations": {
            "ascii": "For each pair (m1, m2) where distance < link_distance:\n    if (m1.energy - m2.energy) ≥ 10 and m1.energy > exchange_amount:\n        m1.energy -= exchange_amount\n        m2.energy += exchange_amount\n        Create flashing link visualization\n    else if (m2.energy - m1.energy) ≥ 10 and m2.energy > exchange_amount:\n        m2.energy -= exchange_amount  \n        m1.energy += exchange_amount\n        Create flashing link visualization",
            "latex": "$$\\forall (i,j) \\in \\mathcal{M} \\times \\mathcal{M}, i \\neq j:$$\n$$\\text{if } d(i,j) < d_{link} \\text{ and } E_i - E_j \\geq \\Delta E_{threshold} \\text{ and } E_i > E_{exchange}:$$\n$$E_i^{t+1} = E_i^t - E_{exchange}$$\n$$E_j^{t+1} = E_j^t + E_{exchange}$$\n$$\\text{Create visual link } L(i,j,t) \\text{ for duration } \\tau$$"
          }
        },
        {
          "name": "Energy Depletion Algorithm",
          "representations": {
            "ascii": "If current_time - last_depletion_time > depletion_interval:\n    For each model:\n        if model.energy > 0:\n            model.energy -= depletion_amount\n    last_depletion_time = current_time",
            "latex": "$$E_i^{t+1} = \\max(0, E_i^t - \\delta E \\cdot \\mathbb{1}_{t \\equiv 0 \\pmod{\\Delta t}})$$\n$$\\text{where } \\delta E = 1, \\Delta t = 3000\\text{ms}$$"
          }
        }
      ]
    },
    {
      "category": "Connection Detection Algorithm",
      "algorithms": [
        {
          "name": "Connection Detection Algorithm",
          "representations": {
            "ascii": "For i = 0 to models.length-1:\n    For j = i+1 to models.length-1:\n        distance = sqrt((m1.x - m2.x)² + (m1.y - m2.y)²)\n        if distance < link_distance:\n            opacity = 1 - (distance / link_distance)\n            Draw line with opacity",
            "latex": "$$\\forall i,j: d(i,j) = \\sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}$$\n$$\\text{if } d(i,j) < d_{max}:$$\n$$\\alpha = 1 - \\frac{d(i,j)}{d_{max}}$$\n$$\\text{DrawLine}(i,j,\\alpha)$$"
          }
        }
      ]
    },
    {
      "category": "Bulk Spawn Detection Algorithm",
      "algorithms": [
        {
          "name": "Bulk Spawn Detection Algorithm",
          "representations": {
            "ascii": "spawn_click_count += 1\nIf spawn_click_count ≥ threshold within time_window:\n    Show bulk spawn controls\nElse:\n    Reset counter after time_window expires",
            "latex": "$$S_{count}^{t+1} = S_{count}^t + 1 \\cdot \\mathbb{1}_{click}$$\n$$\\text{if } S_{count} \\geq S_{threshold} \\text{ within } T_{window}:$$\n$$\\text{ShowControls}()$$\n$$\\text{else if } t > t_{last} + T_{window}: S_{count} = 0$$"
          }
        }
      ]
    }
  ],
  "conclusion": {
    "summary": "These algorithms create the emergent behaviors observed in the simulation, from coordinated swarm movements to resource-based cooperation in stigmergy mode.",
    "source_link": "https://github.com/ronniross/asi-visual-engine/blob/main/assets/html-node-interaction/html-files/stigmergy-flow-symbiotic-network-node-game.html"
  },
  "author": "Ronni Ross",
  "year": 2025
}
